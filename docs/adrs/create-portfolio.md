# Товар

## Status

---

Предложение

## Context

---

Необходимо реализовать функционал просмотра инвестором баланса портфеля.
[Требования](https://docs.google.com/document/d/1DUFQN1GRy39zRMPpAQzdSCkU6NQ3lBxFG0v48o7sHt8/edit#)
Необходимо реализовать функционал внесения инвестором товара в свой портфель.
[Требования](https://docs.google.com/document/d/1SDawYYFYIkpX-kCsV7bpX1GtRMHevSZascpFvy37QTM/edit#heading=h.2snfcrwzlkcf)

## Decision

---

### Новый микросервис

---

Создание нового микросервиса, отвечающего за работу с портфелем, в частности получение баланса портфеля и внесение товара в свой портфель.  
Сервис будет объединять в себе Commands и Queries.

### Реализация нового сервиса

---
*На данном этапе будут реализованы два метода: метод чтения баланса портфеля и метод внесения инвестором товара в свой портфель.*

#### **Получение**

Клиент отправляет запрос на получение баланса портфеля, фасад принимает запрос, из meta-данных достает токен, а из токена id и отправляет его на микросервис портфеля.
Портфель принимает данный запрос, после чего происходит поиск портфеля по id-клиента, потом составляется ответ:

  - id (из бд)
  - name (из бд, храним локально, чтобы не нагружать сервис товаров)
  - volume (из бд)
  - spent (из бд)
  - earned (из бд)
  - best_ask ?
  - estimate (расчет из best_ask and volume)
  - delta_abs (расчет рestimate and spent)
  - delta_rel (расчет рestimate and spent)


Стоит ли хранить best_ask? Наша-ли это ответственность? Он будет меняться динамически и запрашивать баланс вместе с ним нет смысла.

Далее происходит отправка на фасад, а с фасада клиенту.

#### **Добавление**

Клиент отправляет запрос на добавление товара в портфель, фасад принимает запрос: 
- токен
- name
- volume
- start_price
  
Далее формируется запрос на микросервис портфеля:
- id (из токена)
- name
- volume
- start_price

После чего происходит отправка этого запроса на сервис портфеля, который по имени товара запрашивает у сервиса товаров - *id-товара* (если такого товара нет, то серви товаров создаёт новую запись для этого товара). Далее происходит запись товара в портфель. Клиенту отправляется сообщение - *Товар внесён в портфель*
### Фасад

---

Также будет реализован метод в фасаде для отправки запроса на получения баланса портфеля и внесения товара в свой портфель.

### Общение фасада и portfolio-service'а

---

Общение между фасадом и микросервисом будет осуществляться по протоколу grpc.

### Предлагаемые proto-файлы

---

```protobuf
service PortfolioService {
	rpc GetPortfolio(GetPortfolioRequest) returns (PortfolioResponse);
	rpc AddProduct(ChangePortfolioRequest) returns (PortfolioResponse);
}


message GetPortfolioRequest {
	string id = 1;
}

message ChangePortfolioRequest {
    string id = 1;
	string name = 2;
	double volume = 3;
    double start_price = 4;
}

message PortfolioResponse {
    message Product {
        string id = 1;
        string name = 2
        int32 volume = 3;
        double spent = 4;
        double earned = 5;
        double best_ask = 6;
        double estimate = 7;
        double delta_abs = 8;
        double delta_rel = 9;
    }

    message Total {
        double spent = 1;
        double earned = 2;
        double estimate = 3;
        double delta_abs = 4;
        double delta_rel = 5;
    }

    repeated Product products = 1;
    Total total = 2;
}
```
---

### Идемпотентность

---

Клиент будет передавать некий ключ уникальности запроса. Таким образом, серверу по этому ключу нужно определить, обрабатывался ли этот запрос ранее. Если нет (новый запрос), обрабатываем и сохраняем результат обработки, да (повторный запрос) - загружаем результат и возвращаем его без обработки.

## Consequences

---

1. Повторение запросов на фасад и на сервис
2. Для получения баланса портфеля и внесения товара в свой портфель имеется отдельный сервис
3. Тесная связь фасада с сервисом
